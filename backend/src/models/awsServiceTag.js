/**
 * AWSサービスタグモデル
 * DynamoDBでのAWSサービスタグ管理
 */

const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, PutCommand, GetCommand, DeleteCommand, QueryCommand, ScanCommand, UpdateCommand } = require('@aws-sdk/lib-dynamodb');

class AWSServiceTagModel {
  constructor() {
    // DynamoDBクライアントの初期化
    const client = new DynamoDBClient({
      region: process.env.AWS_REGION || 'ap-northeast-1',
      ...(process.env.NODE_ENV === 'development' && {
        endpoint: process.env.DYNAMODB_ENDPOINT || 'http://localhost:8000'
      })
    });
    
    this.docClient = DynamoDBDocumentClient.from(client);
    this.tableName = process.env.AWS_SERVICE_TAG_TABLE_NAME || 'AWSServiceTags';
  }

  /**
   * タグを作成
   * @param {Object} tagData - タグデータ
   * @returns {Promise<Object>} 作成結果
   */
  async createTag(tagData) {
    try {
      const now = new Date().toISOString();
      const tagId = this.generateTagId(tagData.name);
      
      const tag = {
        tagId: tagId,
        name: tagData.name,
        nameJa: tagData.nameJa || tagData.name,
        description: tagData.description || '',
        descriptionJa: tagData.descriptionJa || tagData.description || '',
        
        // タグ分類
        category: tagData.category || 'general', // general, technical, business, region
        type: tagData.type || 'feature', // feature, technology, use-case, industry
        
        // 表示設定
        color: tagData.color || '#2196F3',
        icon: tagData.icon || null,
        displayOrder: tagData.displayOrder || 0,
        
        // 統計情報
        usageCount: 0,
        popularityScore: 0,
        
        // メタデータ
        isActive: tagData.isActive !== false,
        isOfficial: tagData.isOfficial || false, // AWS公式タグかどうか
        isAutoGenerated: tagData.isAutoGenerated || false,
        
        // 関連情報
        aliases: tagData.aliases || [], // 別名・同義語
        relatedTags: tagData.relatedTags || [],
        
        createdAt: now,
        updatedAt: now,
        createdBy: tagData.createdBy || 'system',
        metadata: tagData.metadata || {}
      };

      const command = new PutCommand({
        TableName: this.tableName,
        Item: tag,
        ConditionExpression: 'attribute_not_exists(tagId)'
      });

      await this.docClient.send(command);
      return { success: true, tag };
    } catch (error) {
      if (error.name === 'ConditionalCheckFailedException') {
        throw new Error('タグが既に存在します');
      }
      console.error('タグ作成エラー:', error);
      throw new Error(`タグの作成に失敗しました: ${error.message}`);
    }
  }

  /**
   * タグを取得
   * @param {string} tagId - タグID
   * @returns {Promise<Object|null>} タグデータまたはnull
   */
  async getTag(tagId) {
    try {
      const command = new GetCommand({
        TableName: this.tableName,
        Key: { tagId }
      });

      const result = await this.docClient.send(command);
      return result.Item || null;
    } catch (error) {
      console.error('タグ取得エラー:', error);
      throw new Error(`タグの取得に失敗しました: ${error.message}`);
    }
  }

  /**
   * 全タグを取得
   * @param {Object} options - 取得オプション
   * @returns {Promise<Object[]>} タグ配列
   */
  async getAllTags(options = {}) {
    try {
      const params = {
        TableName: this.tableName
      };

      // フィルタ条件
      const filterExpressions = [];
      const expressionAttributeValues = {};

      if (options.activeOnly !== false) {
        filterExpressions.push('isActive = :active');
        expressionAttributeValues[':active'] = true;
      }

      if (options.category) {
        filterExpressions.push('category = :category');
        expressionAttributeValues[':category'] = options.category;
      }

      if (options.type) {
        filterExpressions.push('#type = :type');
        params.ExpressionAttributeNames = { '#type': 'type' };
        expressionAttributeValues[':type'] = options.type;
      }

      if (options.isOfficial !== undefined) {
        filterExpressions.push('isOfficial = :isOfficial');
        expressionAttributeValues[':isOfficial'] = options.isOfficial;
      }

      if (filterExpressions.length > 0) {
        params.FilterExpression = filterExpressions.join(' AND ');
        params.ExpressionAttributeValues = expressionAttributeValues;
      }

      const command = new ScanCommand(params);
      const result = await this.docClient.send(command);
      
      let tags = result.Items || [];

      // ソート
      if (options.sortBy === 'popularity') {
        tags.sort((a, b) => (b.popularityScore || 0) - (a.popularityScore || 0));
      } else if (options.sortBy === 'usage') {
        tags.sort((a, b) => (b.usageCount || 0) - (a.usageCount || 0));
      } else if (options.sortBy === 'name') {
        tags.sort((a, b) => a.name.localeCompare(b.name));
      } else {
        // デフォルト: 表示順序
        tags.sort((a, b) => (a.displayOrder || 0) - (b.displayOrder || 0));
      }

      return tags;
    } catch (error) {
      console.error('全タグ取得エラー:', error);
      throw new Error(`タグ一覧の取得に失敗しました: ${error.message}`);
    }
  }

  /**
   * タグを更新
   * @param {string} tagId - タグID
   * @param {Object} updateData - 更新データ
   * @returns {Promise<Object>} 更新結果
   */
  async updateTag(tagId, updateData) {
    try {
      const now = new Date().toISOString();
      
      // 更新可能なフィールド
      const allowedFields = [
        'nameJa', 'description', 'descriptionJa', 'category', 'type',
        'color', 'icon', 'displayOrder', 'isActive', 'isOfficial',
        'aliases', 'relatedTags', 'metadata'
      ];
      
      const updateExpression = [];
      const expressionAttributeNames = {};
      const expressionAttributeValues = { ':updatedAt': now };

      allowedFields.forEach(field => {
        if (updateData[field] !== undefined) {
          if (field === 'type') {
            updateExpression.push(`#type = :${field}`);
            expressionAttributeNames['#type'] = 'type';
          } else {
            updateExpression.push(`#${field} = :${field}`);
            expressionAttributeNames[`#${field}`] = field;
          }
          expressionAttributeValues[`:${field}`] = updateData[field];
        }
      });

      if (updateExpression.length === 0) {
        throw new Error('更新するフィールドが指定されていません');
      }

      updateExpression.push('#updatedAt = :updatedAt');
      expressionAttributeNames['#updatedAt'] = 'updatedAt';

      const command = new UpdateCommand({
        TableName: this.tableName,
        Key: { tagId },
        UpdateExpression: `SET ${updateExpression.join(', ')}`,
        ExpressionAttributeNames: expressionAttributeNames,
        ExpressionAttributeValues: expressionAttributeValues,
        ConditionExpression: 'attribute_exists(tagId)',
        ReturnValues: 'ALL_NEW'
      });

      const result = await this.docClient.send(command);
      return { success: true, tag: result.Attributes };
    } catch (error) {
      if (error.name === 'ConditionalCheckFailedException') {
        throw new Error('タグが見つかりません');
      }
      console.error('タグ更新エラー:', error);
      throw new Error(`タグの更新に失敗しました: ${error.message}`);
    }
  }

  /**
   * タグを削除
   * @param {string} tagId - タグID
   * @returns {Promise<boolean>} 削除成功可否
   */
  async deleteTag(tagId) {
    try {
      const command = new DeleteCommand({
        TableName: this.tableName,
        Key: { tagId },
        ConditionExpression: 'attribute_exists(tagId) AND usageCount = :zero',
        ExpressionAttributeValues: { ':zero': 0 }
      });

      await this.docClient.send(command);
      return true;
    } catch (error) {
      if (error.name === 'ConditionalCheckFailedException') {
        throw new Error('タグが見つからないか、使用中のため削除できません');
      }
      console.error('タグ削除エラー:', error);
      throw new Error(`タグの削除に失敗しました: ${error.message}`);
    }
  }

  /**
   * タグの使用回数を更新
   * @param {string} tagId - タグID
   * @param {number} increment - 増減値
   * @returns {Promise<boolean>} 更新成功可否
   */
  async updateUsageCount(tagId, increment) {
    try {
      const command = new UpdateCommand({
        TableName: this.tableName,
        Key: { tagId },
        UpdateExpression: 'ADD usageCount :increment SET updatedAt = :updatedAt',
        ExpressionAttributeValues: {
          ':increment': increment,
          ':updatedAt': new Date().toISOString()
        },
        ConditionExpression: 'attribute_exists(tagId)'
      });

      await this.docClient.send(command);
      return true;
    } catch (error) {
      console.error('使用回数更新エラー:', error);
      return false;
    }
  }

  /**
   * 人気タグを取得
   * @param {number} limit - 取得件数
   * @param {Object} options - オプション
   * @returns {Promise<Object[]>} 人気タグ配列
   */
  async getPopularTags(limit = 20, options = {}) {
    try {
      const params = {
        TableName: this.tableName,
        FilterExpression: 'isActive = :active',
        ExpressionAttributeValues: {
          ':active': true
        }
      };

      // カテゴリフィルタ
      if (options.category) {
        params.FilterExpression += ' AND category = :category';
        params.ExpressionAttributeValues[':category'] = options.category;
      }

      const command = new ScanCommand(params);
      const result = await this.docClient.send(command);
      
      let tags = result.Items || [];

      // 人気度でソート（使用回数 + 人気スコア）
      tags.sort((a, b) => {
        const scoreA = (a.usageCount || 0) + (a.popularityScore || 0);
        const scoreB = (b.usageCount || 0) + (b.popularityScore || 0);
        return scoreB - scoreA;
      });

      return tags.slice(0, limit);
    } catch (error) {
      console.error('人気タグ取得エラー:', error);
      throw new Error(`人気タグの取得に失敗しました: ${error.message}`);
    }
  }

  /**
   * タグを検索
   * @param {string} searchTerm - 検索語
   * @param {Object} options - 検索オプション
   * @returns {Promise<Object[]>} 検索結果
   */
  async searchTags(searchTerm, options = {}) {
    try {
      const language = options.language || 'en';
      
      const params = {
        TableName: this.tableName,
        FilterExpression: language === 'ja'
          ? 'contains(nameJa, :term) OR contains(descriptionJa, :term)'
          : 'contains(#name, :term) OR contains(description, :term)',
        ExpressionAttributeNames: language === 'en' ? { '#name': 'name' } : undefined,
        ExpressionAttributeValues: {
          ':term': searchTerm
        }
      };

      // アクティブなタグのみ
      if (options.activeOnly !== false) {
        params.FilterExpression += ' AND isActive = :active';
        params.ExpressionAttributeValues[':active'] = true;
      }

      const command = new ScanCommand(params);
      const result = await this.docClient.send(command);
      
      let tags = result.Items || [];

      // 関連度でソート
      tags.sort((a, b) => {
        const scoreA = this.calculateRelevanceScore(a, searchTerm, language);
        const scoreB = this.calculateRelevanceScore(b, searchTerm, language);
        return scoreB - scoreA;
      });

      return tags;
    } catch (error) {
      console.error('タグ検索エラー:', error);
      throw new Error(`タグ検索に失敗しました: ${error.message}`);
    }
  }

  /**
   * カテゴリ別タグ統計を取得
   * @returns {Promise<Object>} カテゴリ別統計
   */
  async getTagStatistics() {
    try {
      const allTags = await this.getAllTags({ activeOnly: false });
      
      const stats = {
        totalTags: allTags.length,
        activeTags: allTags.filter(t => t.isActive).length,
        officialTags: allTags.filter(t => t.isOfficial).length,
        autoGeneratedTags: allTags.filter(t => t.isAutoGenerated).length,
        
        categoryDistribution: {},
        typeDistribution: {},
        
        totalUsage: allTags.reduce((sum, t) => sum + (t.usageCount || 0), 0),
        averageUsage: 0,
        
        timestamp: new Date().toISOString()
      };

      // カテゴリ別分布
      allTags.forEach(tag => {
        const category = tag.category || 'general';
        stats.categoryDistribution[category] = (stats.categoryDistribution[category] || 0) + 1;
      });

      // タイプ別分布
      allTags.forEach(tag => {
        const type = tag.type || 'feature';
        stats.typeDistribution[type] = (stats.typeDistribution[type] || 0) + 1;
      });

      // 平均使用回数
      stats.averageUsage = stats.activeTags > 0 
        ? Math.round(stats.totalUsage / stats.activeTags) 
        : 0;

      return stats;
    } catch (error) {
      console.error('タグ統計取得エラー:', error);
      throw new Error(`タグ統計の取得に失敗しました: ${error.message}`);
    }
  }

  /**
   * タグクラウドデータを取得
   * @param {Object} options - オプション
   * @returns {Promise<Object[]>} タグクラウドデータ
   */
  async getTagCloudData(options = {}) {
    try {
      const limit = options.limit || 50;
      const minUsage = options.minUsage || 1;
      
      const popularTags = await this.getPopularTags(limit * 2, options);
      
      // 最小使用回数でフィルタ
      const filteredTags = popularTags.filter(tag => (tag.usageCount || 0) >= minUsage);
      
      // タグクラウド用データに変換
      const maxUsage = Math.max(...filteredTags.map(t => t.usageCount || 0));
      const minUsageInData = Math.min(...filteredTags.map(t => t.usageCount || 0));
      
      const tagCloudData = filteredTags.slice(0, limit).map(tag => {
        const usage = tag.usageCount || 0;
        // 使用回数を1-5のサイズレベルに正規化
        const sizeLevel = maxUsage > minUsageInData 
          ? Math.ceil(((usage - minUsageInData) / (maxUsage - minUsageInData)) * 4) + 1
          : 3;
        
        return {
          tagId: tag.tagId,
          name: tag.name,
          nameJa: tag.nameJa,
          usageCount: usage,
          sizeLevel: sizeLevel,
          color: tag.color,
          category: tag.category,
          type: tag.type
        };
      });

      return tagCloudData;
    } catch (error) {
      console.error('タグクラウドデータ取得エラー:', error);
      throw new Error(`タグクラウドデータの取得に失敗しました: ${error.message}`);
    }
  }

  /**
   * タグIDを生成
   * @param {string} name - タグ名
   * @returns {string} タグID
   * @private
   */
  generateTagId(name) {
    const crypto = require('crypto');
    const normalized = name.toLowerCase().replace(/[^a-z0-9]/g, '');
    const hash = crypto.createHash('md5').update(normalized + Date.now()).digest('hex').substring(0, 8);
    return `tag_${hash}`;
  }

  /**
   * 検索関連度スコアを計算
   * @param {Object} tag - タグデータ
   * @param {string} searchTerm - 検索語
   * @param {string} language - 言語
   * @returns {number} 関連度スコア
   * @private
   */
  calculateRelevanceScore(tag, searchTerm, language) {
    let score = 0;
    const term = searchTerm.toLowerCase();
    
    const fields = language === 'ja' 
      ? [tag.nameJa, tag.descriptionJa]
      : [tag.name, tag.description];

    fields.forEach((field, index) => {
      if (field && field.toLowerCase().includes(term)) {
        // フィールドの重要度に応じてスコア調整
        const weight = [3, 1][index] || 1;
        score += weight;
        
        // 完全一致の場合はボーナス
        if (field.toLowerCase() === term) {
          score += 5;
        }
      }
    });

    // 別名での一致もチェック
    if (tag.aliases && Array.isArray(tag.aliases)) {
      tag.aliases.forEach(alias => {
        if (alias.toLowerCase().includes(term)) {
          score += 2;
          if (alias.toLowerCase() === term) {
            score += 3;
          }
        }
      });
    }

    // 使用回数も考慮
    score += (tag.usageCount || 0) * 0.1;

    return score;
  }
}

module.exports = AWSServiceTagModel;